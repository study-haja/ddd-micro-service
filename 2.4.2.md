## 마이크로서비스 운영과 관리를 위한 플랫폼 패턴

인프라를 선택했다면 다음으로 애플리케이션을 운영하고 관리하는 환경을 구성하는 방법을 잘 선택해야한다. 그 이유는 MSA 시스템을 구성하는 수많은 마이크로서비스를 하나하나 수동으로 빌드하고 배포한다면 비효율적이고 큰 혼란을 가져올 것이기 때문이다. 

따라서 이러한 과정을 자동화 해주는 것이 중요해졌다.



### 개발 지원 환경: 데브옵스 인프라 구성

데브 옵스는 개발과 운영을 병행 가능하게끔 높은 품질로 소프트웨어를 빠르게 개발하도록 지원하는 빌드, 테스트, 배포를 위한 자동화 환경을 말한다.

수동배포의 문제점은 다음과 같다.

1. 많은 시간 소요
2. 비지니스 민첩성이 낮음 (시간에 구애를 받음)
3. 엄격한 배포 구조 (사람이 수동으로 배포)

따라서 이를 해결하기 위해서는 자동화가 필요한데 이를 보통 CI/CD 라 부른다. CI는 자동으로 통합 및 테스트하고 그 결과를 리포트에 기록하는 것을 말하고 CD는 자동으로 실행환경에 내보내는 것을 말한다.



### 빌드/배포 파이프라인 설계

빌드/배포되는 과정 동안 수행해야 할 태스크가 정의된 것을 빌드/배포 파이프라인이라고 한다. 즉 통합 및 배포까지 이어지는 일련의 프로세스를 하나로 연계해서 자동화하고 시각화된 절차로 구축하는 것을 말한다.

최근 클라우드 같은 가상 환경이 대중화 하면서 완전한 자동화가 가능해졌다. 인프라 구성을 마치 프로그래밍하는 것처럼 처리하고 소수의 인원으로 많은 컨테이너 배포 처리를 할 수 있게 됐는데, 이를 가리켜 Infrastructure as Code 라 부른다. 이를 이용하면 다음과 같은 장점이 있다.

1. 완벽하게 자동화
2. 대규모 인프라 관리 수행
3. 코드라 쉽게 공유 가능 및 재사용 가능

하지만 모든 과정을 자동화하는 것은 어렵다. 또한 어떤 애플리케이션은 성격에 따라 이 같은 전체적인 자동화가 필요 없을 수도 있다. 따라서 MSA에서는 각 레포지토리 별로 CI/CD를 설계해야한다.



### 마이크로서비스 생태계와 운영 관리 요소의 탄생

넷플릭스가 대규모 시스템 장애를 겪고 이를 계기로 모놀리스에서 MSA로 전환하게 되었다. 그리고 넷플릭스의 기술력에 의구심을 갖는 사람들에게 보란듯이 오픈소스를 공개했다. 이를 OSS라 부르며 이 안에는 마이크로서비스 간의 라우팅과 로드밸런싱을 위한 줄과 리본, 모니터링을 위한 히스트릭스, 서비스 등록을 위한 유래카등이 포함되어있다.

이후 2013년 도커가 등장하고, 스프링 부트도 발표되고, 컨테이너 오케스트레이션인 구글의 쿠버네티스가 등장했다. 이처럼 다양한 플랫폼이나 도구 등을 통해 마이크로서비스 생태계의 발전을 계속 이끌었고, MSA의 문제 영역들이 논의되고 해결되어 왔음을 알 수 있다.



### 경험으로 획득한 지혜 : 마이크로서비스 관리/운영 패턴

넷플릭스가 OSS를 공개하고 나서 마이크로서비스 생태계에 크게 도움이 되었고, 특히 마이크로서비스 관리와 운영을 지원하는 전형적인 마이크로서비스 애플리케이션 패턴으로 자리 잡았다.

또한 다른 진영에서는 스프링 클라우드라는 것을 발표해 OSS 모듈들을 잘 사용하게 만들었다. 즉 스프링 부트와 스프링 클라우드를 이용하면 마이크로서비스 애플리케이션의 운영 환경을 쉽게 구축 할 수 있다.



### 스프링 클라우드: 스프링 부트 + 넷플릭스 OSS

간단하게 말하면 마이크로서비스에 필요한 줄, 리본, 히스트릭, 유레카등을 스프링 진영에서 쉽게 사용할 수 있도록 만든 통합 프레임워크이다. 



### 다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴

클라이언트가 여러 개의 마이크로서비스를 호출하기 위해서는 최적 경로를 찾아주는 라우팅 기능(줄)과 적절한 부하 분산을 위한 로드 밸런싱 기능(리본)이 제공돼야 한다. 

라우터는 최적 경로를 찾기 위해 서비스 명칭에 해당하는 IP 주소를 알아야 한다. 하지만 라우팅 정보를 클라이언트가 가지고 있으면 클라우드 환경은 유동 IP이기 때문에 매번 클라이언트에게 IP를 제공해야 한다.

따라서 마이크로 서비스의 명칭과 유동적인 IP 정보를 매핑해서 보관하는 저장소를 두는 것이 좋다. 이를 OSS로 빗대어 보자면 유레카가 담당하고, 이런 패턴을 서비스 레지스트리 패턴이라 부른다.

동작은 다음과 같다.

1. 서비스 인스턴스가 로딩될 때 자신의 이름과 할당된 IP 주소를 레지스트리 서비스에 등록한다.
2. 클라이언트에서 해당 서비스명을 호출할 때 라우터가 레지스트리 서비스를 검색해 해당 서비스의 이름과 매핑된 IP 정보를 확인후 호출한다.
3. 이 레지스트리 서비스는 모든 마이크로 서비스의 인스턴스의 주소를 알고 있는 서비스 매핑 저장소가 된다.
4. 모든 마이크로서비스가 처음 기동할 때 자신의 위치 정보를 저장하고 서비스가 종료될 때 위치 정보가 삭제된다.

레지스트리에는 업무 처리를 위한 마이크로서비스뿐만 아니라 관리와 운영을 위한 기반 서비스의 주소도 함께 보관한다 (config 서비스, 모니터링 서비스, 추적 서비스)

그리고 이패턴은 다른 솔루션에도 제공하는데 예를 들어 쿠버네티스의 경우 쿠버네티스 DNS(서비스 레지스트리), 쿠버네티스 서비스(디스커버리)가 있다.

