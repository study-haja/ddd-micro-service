## 마이크로서비스 운영과 관리를 위한 플랫폼 패턴

인프라를 선택했다면 다음으로 애플리케이션을 운영하고 관리하는 환경을 구성하는 방법을 잘 선택해야한다. 그 이유는 MSA 시스템을 구성하는 수많은 마이크로서비스를 하나하나 수동으로 빌드하고 배포한다면 비효율적이고 큰 혼란을 가져올 것이기 때문이다. 

따라서 이러한 과정을 자동화 해주는 것이 중요해졌다.



### 개발 지원 환경: 데브옵스 인프라 구성

데브 옵스는 개발과 운영을 병행 가능하게끔 높은 품질로 소프트웨어를 빠르게 개발하도록 지원하는 빌드, 테스트, 배포를 위한 자동화 환경을 말한다.

수동배포의 문제점은 다음과 같다.

1. 많은 시간 소요
2. 비지니스 민첩성이 낮음 (시간에 구애를 받음)
3. 엄격한 배포 구조 (사람이 수동으로 배포)

따라서 이를 해결하기 위해서는 자동화가 필요한데 이를 보통 CI/CD 라 부른다. CI는 자동으로 통합 및 테스트하고 그 결과를 리포트에 기록하는 것을 말하고 CD는 자동으로 실행환경에 내보내는 것을 말한다.



### 빌드/배포 파이프라인 설계

빌드/배포되는 과정 동안 수행해야 할 태스크가 정의된 것을 빌드/배포 파이프라인이라고 한다. 즉 통합 및 배포까지 이어지는 일련의 프로세스를 하나로 연계해서 자동화하고 시각화된 절차로 구축하는 것을 말한다.

최근 클라우드 같은 가상 환경이 대중화 하면서 완전한 자동화가 가능해졌다. 인프라 구성을 마치 프로그래밍하는 것처럼 처리하고 소수의 인원으로 많은 컨테이너 배포 처리를 할 수 있게 됐는데, 이를 가리켜 Infrastructure as Code 라 부른다. 이를 이용하면 다음과 같은 장점이 있다.

1. 완벽하게 자동화
2. 대규모 인프라 관리 수행
3. 코드라 쉽게 공유 가능 및 재사용 가능

하지만 모든 과정을 자동화하는 것은 어렵다. 또한 어떤 애플리케이션은 성격에 따라 이 같은 전체적인 자동화가 필요 없을 수도 있다. 따라서 MSA에서는 각 레포지토리 별로 CI/CD를 설계해야한다.



### 마이크로서비스 생태계와 운영 관리 요소의 탄생

넷플릭스가 대규모 시스템 장애를 겪고 이를 계기로 모놀리스에서 MSA로 전환하게 되었다. 그리고 넷플릭스의 기술력에 의구심을 갖는 사람들에게 보란듯이 오픈소스를 공개했다. 이를 OSS라 부르며 이 안에는 마이크로서비스 간의 라우팅과 로드밸런싱을 위한 줄과 리본, 모니터링을 위한 히스트릭스, 서비스 등록을 위한 유래카등이 포함되어있다.

이후 2013년 도커가 등장하고, 스프링 부트도 발표되고, 컨테이너 오케스트레이션인 구글의 쿠버네티스가 등장했다. 이처럼 다양한 플랫폼이나 도구 등을 통해 마이크로서비스 생태계의 발전을 계속 이끌었고, MSA의 문제 영역들이 논의되고 해결되어 왔음을 알 수 있다.



### 경험으로 획득한 지혜 : 마이크로서비스 관리/운영 패턴

넷플릭스가 OSS를 공개하고 나서 마이크로서비스 생태계에 크게 도움이 되었고, 특히 마이크로서비스 관리와 운영을 지원하는 전형적인 마이크로서비스 애플리케이션 패턴으로 자리 잡았다.

또한 다른 진영에서는 스프링 클라우드라는 것을 발표해 OSS 모듈들을 잘 사용하게 만들었다. 즉 스프링 부트와 스프링 클라우드를 이용하면 마이크로서비스 애플리케이션의 운영 환경을 쉽게 구축 할 수 있다.



### 스프링 클라우드: 스프링 부트 + 넷플릭스 OSS

간단하게 말하면 마이크로서비스에 필요한 줄, 리본, 히스트릭, 유레카등을 스프링 진영에서 쉽게 사용할 수 있도록 만든 통합 프레임워크이다. 



### 다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴

클라이언트가 여러 개의 마이크로서비스를 호출하기 위해서는 최적 경로를 찾아주는 라우팅 기능(줄)과 적절한 부하 분산을 위한 로드 밸런싱 기능(리본)이 제공돼야 한다. 

라우터는 최적 경로를 찾기 위해 서비스 명칭에 해당하는 IP 주소를 알아야 한다. 하지만 라우팅 정보를 클라이언트가 가지고 있으면 클라우드 환경은 유동 IP이기 때문에 매번 클라이언트에게 IP를 제공해야 한다.

따라서 마이크로 서비스의 명칭과 유동적인 IP 정보를 매핑해서 보관하는 저장소를 두는 것이 좋다. 이를 OSS로 빗대어 보자면 유레카가 담당하고, 이런 패턴을 서비스 레지스트리 패턴이라 부른다.

동작은 다음과 같다.

1. 서비스 인스턴스가 로딩될 때 자신의 이름과 할당된 IP 주소를 레지스트리 서비스에 등록한다.
2. 클라이언트에서 해당 서비스명을 호출할 때 라우터가 레지스트리 서비스를 검색해 해당 서비스의 이름과 매핑된 IP 정보를 확인후 호출한다.
3. 이 레지스트리 서비스는 모든 마이크로 서비스의 인스턴스의 주소를 알고 있는 서비스 매핑 저장소가 된다.
4. 모든 마이크로서비스가 처음 기동할 때 자신의 위치 정보를 저장하고 서비스가 종료될 때 위치 정보가 삭제된다.

레지스트리에는 업무 처리를 위한 마이크로서비스뿐만 아니라 관리와 운영을 위한 기반 서비스의 주소도 함께 보관한다 (config 서비스, 모니터링 서비스, 추적 서비스)

그리고 이패턴은 다른 솔루션에도 제공하는데 예를 들어 쿠버네티스의 경우 쿠버네티스 DNS(서비스 레지스트리), 쿠버네티스 서비스(디스커버리)가 있다.



### 서비스 단일 진입을 위한 API 게이트웨이 패턴

여러 클라이언트가 여러 개의 서버 서비스를 각각 호출하게 된다면 매우 복잡한 호출 관계가 만들어지므로, 이러한 복잡성을 통제하기 위해서 API 게이트웨이를 둘수 있다.

다른 서비스와 연계하여 다음 기능을 제공할수 있다.

- 레지스트리 서비스와 연계한 동적 라우팅, 로드 벨런싱
- 보안 : 권한 서비스와 연계한 인증/인가
- 로그 집계 서비스와 연계한 로깅
- 메트릭(에러율, 평균/최고 지연시간, ...)
- 트레이싱 서비스와 연계한 서비스 추적
- 모니터링 서비스와 연계한 장애 격리

다른 클라우드 플랫폼에서도 이러한 API 게이트웨이 패턴을 지원하는데, 대표적으로 쿠버네티스의 경우 자체 기능인 쿠버네티스 서비스와 인그레스 리소스를 제공함.



### BFF 패턴

BFF 패턴은 API 게이트웨이와 같은 진입점을 하나로 두지 않고 프런트엔드의 유형에 따라 각각 두는 패턴이다. 프런트엔드를 위한 백엔드라는 의미로 BFF(Backend For Frontend)라고 부른다.



### 외부 구성 저장소 패턴

- 외부 저장소에 각 마이크로서비스의 외부 환경 설정 정보를 공동으로 저장하는 패턴
- 쿠버네티스에서는 이러한 외부 구성 저장소 패턴을 쿠버네티스 ConfigMap으로 제공한다.



### 인증/인가 패턴

- 중앙 집중식 세션 관리
  - MSA에서는 서버 세션에 사용자의 로그인 정보 및 권한 정보를 저장하면 모든 MS에서 세션정보를 공유할수 없으므로, 각자의 서비스에 세션을 저장하지 않고 공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자 데이터를 얻게 한다. 이때 세션 저장소로 보통 레디스(Redis)나 멤캐시드(Memcached)를 사용한다.
- 클라이언트 토큰
  1. 브라우저가 서버에 사용자명과 패스워드로 인증을 요청
  2. 서버는 인증후 토큰을 생성하고 토큰에 사용자 정보의 인증/인가 정보를 포함해서 브라우저에 전송
  3. 브라우저는 서버 리소스를 요청할 때 토큰을 함께 보낸다. 서버의 서비스는 토큰 정보를 확인한후 자원접근을 허가
- API 게이트웨이를 사용한 클라이언트 토큰
  1. 클라이언트가 리소스 서비스에 접근을 요청하면 API 게이트웨이는 인증 서비스에게 전달
  2. 인증 서비스는 해당 요청이 인증된 사용자가 보낸 것인지(인증), 해당 리소스에 대한 접근 권한이 있는지(인가)확인하고, 모두 확인하고 나면 리소스에 접근 가능한 증명서인 액세스 토큰을 발급
  3. 클라이언트는 다시 엑세스 토큰을 활용해 접근을 요청
  4. 리소스 서비스는 이러한 요청이 엑세스 토큰을 포함하고 있는지 판단해서 리소스에 대한 접근을 허용



### 장애 및 실패 처리를 위한 서킷 브레이커 패턴

- A라는 서비스가 B라는 서비스에 의존하는 상황에서, B라는 서비스에 장애가 발생했다면 A라는 서비스는 B 서비스 호출에 대한 연속 실패 횟수가 임곗값을 초과하면 회로차단기가 작동해서 이후에 서비스를 호출하려는 모든 시도를 즉시 실패하게 만든다.



#### 모니터링과 추적 패턴

- 배포된 서비스를 모니터링할수 있는 환경을 제공
- 서비스 트랜젝션의 호출을 추적할수 있는 환경을 제공



### 중앙화된 로그 집계 패턴

- 서비스가 로그 스트림의 전달이나 저장에 관여할 필요 없도록 로그를 집계하는 패턴
- 대표적으로 ELK(Elasticsearch,Logstash,Kibana)라는 세가지 오픈소스 프로젝트를 기반으로 데이터 분석 환경을 구성
  - Elasticsearch는 검색엔진
  - Logstash는 서버측 로그 수집기
  - Kibana는 로그를 시각화해주는 앱



### MSA 기술 변화 흐름

초기 MSA는 넷플릭스 OSS나 스프링클라우드를 이용해 각각의 서비스를 별도로 만들어서 해결하거나 유연성처럼 수평 확장이 필요한 요소는 AWS IaaS 서비스를 이용해 해결했다. 즉 문제마다 상이한 기술로 해결할 수 밖에 없었다.

그러나 쿠버네티스나 오픈시프트 같은 제품들로 여러 문제의 해결책을 한꺼번에 제공하는 솔루션이 등장했다. 특히 쿠버네티스가 소프트웨어 차원, 즉 컨테이너의 레플리카 기술로 탐색, 호출 문제와 함께 통합해서 지원하면서 쿠버네티스가 각광받고 있다.

최근에는 이스티오 기술이 함께 사용되고 있다.



### 서비스 메시 패턴

초창기 MSA 의 문제점은 API 게이트웨이, 서비스 레지스트리, 컨피그 서비스와 같이 운영 관리를 위한 여러 개의 기반 서비스를 별도로 각각 만들어야 한다는 번거러움과 더불어 업무 처리 마이크로서비스에 스프링 클라우드 서비스를 사용하기 위한 라이브러리를 비즈니스 로직과 함께 탑재해야 한다는 점이었다.

따라서 최근에는 비지니스 로직과 분리해서 네트워크 인프라 계층에서 수행하게 하는 서비스 메시 패턴이 선호되고 있다.

서비스 메시는 인프라 레이어로서 서비스 간의 통신을 처리하며 앞에서 언급한 여러 문제 해결 패턴을 포괄한다.

이스티오가 대표적인 예인데 애플리케이션이 배포되는 컨테이너에 완전히 격리되어 별도의 컨테이너로 배포되는 사이드카 패턴을 적용해서 서비스 디스커버리, 라우팅, 로드 밸런싱, 로깅, 모니터링, 보안, 트레이싱 등의 기능을 제공한다.

서비스 메시를 적용한 시스템의 경우 마이크로서비스마다 함께 배포되는 사이드카 프락시에 운영 관리를 위한 기능이 별도로 담겨있기 때문에 마이크로서비스는 순수 비지니스 로직에 집중할 수 있다.

이스티오는 주요기능은 다음과 같다.

1. 트래픽 관리 : 동적 라우팅, 로드 밸런싱
2. 보안 : 보안 통신 채널, 인증, 인가, 암호화
3. 관측성 : 메트릭, 분산 트레이싱, 로깅

스프링 클라우드 및 넷플릭스 OSS와 차별점은 다음과 같다.

1. 애플리케이션 코드의 변경이 거의 없다. (스프링 클라우드, OSS는 비즈니스 로직과 함께 코드로 표현해야 함)
2. 폴리글랏 애플리케이션도 지원한다. (스프링 클라우드, OSS는 자바 언어만 지원 함)
3. 이스티오는 쿠버네티스와 완벼하게 통합된 환경을 지원한다.
