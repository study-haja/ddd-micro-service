## 애플리케이션 패턴

마이크로서비스의 구성과 관계를 설계할 때도 마찬가지로 유연성, 확장성, 독립성등을 염두에 두고 설계해야 한다.

프론트 같은 경우 모노리스로 구현하면 독립적인 변경과 배포가 가능하지 못했다. 만약 백앤드에서 어느 한가지를 변경해야 할 경우 프론트는 덩어리로 재배포를 해야했기 때문에 빌드할 필요가 없는 기능들을 빌드하고 배포해야했다. 

따라서 다음과 같은 패턴들을 이용해 위와 같은 문제를 해결했다.



### UI 컴포지트 패턴 또는 마이크로 프런트엔드

UI 컴포지트 패턴은 기능별로 분리하고 이를 조합하기 위한 프레임 형태의 부모 창을 통해 각 프런트엔드를 조합해서 동작하게 한다. 부모 서비스는 틀만 가지고 있고, 실제 각 기능 표현은 마이크로 프런트엔드 조각이 구현하게 한다. 

이렇게 함으로써 하나의 레포지토리에 백앤드 마이크로 서비스와 마이크로 프런트를 관리하고 독립적으로 빌드 및 배포할 수 있다.



### 마이크로서비스 통신 패턴

* 동기 통신 방식
  * 클라이언트에서 서버 측에 존재하는 마이크로서비스 REST API를호출할 때 사용되는 기본적인 통신 방법
  * 다양한 클라이언트 채널 연계나 라우팅 및 로드 밸런싱을 원활하게 하기 위한 방법으로 중간에 API 게이트웨이를 둘 수 있음
  * 호출이 직관적이라 구현하기 쉽고 가장 많이 쓰임
  * 마이크로서비스 상에서 단점
    * 요청을 보낸 서비스는 반응이 올 때까지 기다림
    * 반응이 오지 않으면 계속 기다리면서 재호출
    * 따라서 여러 서비스간의 연계를 통해 업무를 처리하는 마이크로서비스 구조에서는 연쇄적으로 장애가 발생가능성이 큼
    * 또 서비스가 다른 서비스를 호출해서 얻은 정보를 이용해 기능을 제공한다는 의미는 해당 서비스 간의 의존관계가 높다는 것을 의미
* 비동기 통신 방식
  * 메시지 기반의 비동기는 메세지를 보낸 다음 응답을 기다리지 않고 다음 일을 처리
  * 응답을 받지 않기 때문에 완결성 보장할 수는 없음
  * 메시지 브로커는 다음과 같은 매커니즘을 가짐
    * 메시지를 보냄 - 생산자
    * 메시지를 처리 - 소비자
    * 메시지 보관 - 브로커
  * 메시지 브로커가 메세지 전송을 보장하고 확장을 통해 부하를 막음

즉 메세지 비동기 통신은 메세지 브로커를 사용함으로써 물리적으로 동일한 시스템에 위치할 필요도 없고, 프로세스 공유도 할 필요가 없으며, 동일한 시간대에 동시에 동작하지 않아도 된다. 그리고 탄력성이 높은 서비스가 다운됐을 때 또는 시스템을 더 확장해야 할 때 사용할 수 있는 매우 효과적인 방법이다.



### 저장소 분리 패턴

데이터 중심 어플리케이션(비지니스 로직 처리가 SQL로 몰려있는 경우)에서 특정 관계형 데이터베이스 벤더에 구속되고 복잡해져 유지보수가 어려워지고 성능 문제가 발생 시 SQL 구문 튜닝이나 저장소 증설에 의존할 수 밖에 없다.

또한 이런 구조는 마이크로서비스로 분리하더라도 통합 DB가 여전히 바쁘기 때문에 스케일 아웃도 소용이 없을 것이다.

따라서 저장소 분리 패턴을 이용해 위 문제를 해결할 수 있다. 저장소 분리 패턴은 각 마이크로서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유해야 한다는 것을 말한다.

 이 패턴의 장점은 다음과 같다.

1. 자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않음 (정보 은닉)
2. 각자가 공개한 API를 통해서만 접근 가능 (정보 은닉)
3. 저장소가 격리돼 있기 때문에 각 저장소를 자율적으로 선택 가능 (폴리글랏 저장소)
4. 데이터를 통한 변경의 파급 효과가 줄어듬 (독립적)

하지만 이 패턴의 문제점이 생기는데 다음과 같다.

* 여러 개의 분산된 서비스에 걸쳐 비즈니스 처리를 수행해야 하는 경우 비즈니스 정합성 및 데이터 일관성을 어떻게 보장할지 문제가 생김
