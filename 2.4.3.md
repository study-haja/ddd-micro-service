## 애플리케이션 패턴

마이크로서비스의 구성과 관계를 설계할 때도 마찬가지로 유연성, 확장성, 독립성등을 염두에 두고 설계해야 한다.

프론트 같은 경우 모노리스로 구현하면 독립적인 변경과 배포가 가능하지 못했다. 만약 백앤드에서 어느 한가지를 변경해야 할 경우 프론트는 덩어리로 재배포를 해야했기 때문에 빌드할 필요가 없는 기능들을 빌드하고 배포해야했다. 

따라서 다음과 같은 패턴들을 이용해 위와 같은 문제를 해결했다.



### UI 컴포지트 패턴 또는 마이크로 프런트엔드

UI 컴포지트 패턴은 기능별로 분리하고 이를 조합하기 위한 프레임 형태의 부모 창을 통해 각 프런트엔드를 조합해서 동작하게 한다. 부모 서비스는 틀만 가지고 있고, 실제 각 기능 표현은 마이크로 프런트엔드 조각이 구현하게 한다. 

이렇게 함으로써 하나의 레포지토리에 백앤드 마이크로 서비스와 마이크로 프런트를 관리하고 독립적으로 빌드 및 배포할 수 있다.



### 마이크로서비스 통신 패턴

* 동기 통신 방식
  * 클라이언트에서 서버 측에 존재하는 마이크로서비스 REST API를호출할 때 사용되는 기본적인 통신 방법
  * 다양한 클라이언트 채널 연계나 라우팅 및 로드 밸런싱을 원활하게 하기 위한 방법으로 중간에 API 게이트웨이를 둘 수 있음
  * 호출이 직관적이라 구현하기 쉽고 가장 많이 쓰임
  * 마이크로서비스 상에서 단점
    * 요청을 보낸 서비스는 반응이 올 때까지 기다림
    * 반응이 오지 않으면 계속 기다리면서 재호출
    * 따라서 여러 서비스간의 연계를 통해 업무를 처리하는 마이크로서비스 구조에서는 연쇄적으로 장애가 발생가능성이 큼
    * 또 서비스가 다른 서비스를 호출해서 얻은 정보를 이용해 기능을 제공한다는 의미는 해당 서비스 간의 의존관계가 높다는 것을 의미
* 비동기 통신 방식
  * 메시지 기반의 비동기는 메세지를 보낸 다음 응답을 기다리지 않고 다음 일을 처리
  * 응답을 받지 않기 때문에 완결성 보장할 수는 없음
  * 메시지 브로커는 다음과 같은 매커니즘을 가짐
    * 메시지를 보냄 - 생산자
    * 메시지를 처리 - 소비자
    * 메시지 보관 - 브로커
  * 메시지 브로커가 메세지 전송을 보장하고 확장을 통해 부하를 막음

즉 메세지 비동기 통신은 메세지 브로커를 사용함으로써 물리적으로 동일한 시스템에 위치할 필요도 없고, 프로세스 공유도 할 필요가 없으며, 동일한 시간대에 동시에 동작하지 않아도 된다. 그리고 탄력성이 높은 서비스가 다운됐을 때 또는 시스템을 더 확장해야 할 때 사용할 수 있는 매우 효과적인 방법이다.



### 저장소 분리 패턴

데이터 중심 어플리케이션(비지니스 로직 처리가 SQL로 몰려있는 경우)에서 특정 관계형 데이터베이스 벤더에 구속되고 복잡해져 유지보수가 어려워지고 성능 문제가 발생 시 SQL 구문 튜닝이나 저장소 증설에 의존할 수 밖에 없다.

또한 이런 구조는 마이크로서비스로 분리하더라도 통합 DB가 여전히 바쁘기 때문에 스케일 아웃도 소용이 없을 것이다.

따라서 저장소 분리 패턴을 이용해 위 문제를 해결할 수 있다. 저장소 분리 패턴은 각 마이크로서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유해야 한다는 것을 말한다.

 이 패턴의 장점은 다음과 같다.

1. 자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않음 (정보 은닉)
2. 각자가 공개한 API를 통해서만 접근 가능 (정보 은닉)
3. 저장소가 격리돼 있기 때문에 각 저장소를 자율적으로 선택 가능 (폴리글랏 저장소)
4. 데이터를 통한 변경의 파급 효과가 줄어듬 (독립적)

하지만 이 패턴의 문제점이 생기는데 다음과 같다.

* 여러 개의 분산된 서비스에 걸쳐 비즈니스 처리를 수행해야 하는 경우 비즈니스 정합성 및 데이터 일관성을 어떻게 보장할지 문제가 생김



### 분산 트랜젝션 처리 패턴

분산 트랜젝션 처리에서는 여러 서비스 간의 비즈니스 및 데이터 일관성을 유지할 필요가 있다. 전통적인 방법으로 2단계 커밋(2 phase commit)이 사용되었으나, 다음 단점이 있다.

- 각 서비스에 락이 걸려 availability가 하락하는 문제점이 있다.
- NoSQL 저장소에서는 지원하지 않는다.

이를 개선하기 위해 Saga 패턴을 적용할수 있다.

Saga 패턴은 여러 개의 분산된 서비스를 하나의 트랜젝션으로 묶지 않고 각 로컬 트랜젝션과 보상 트랜젝션을 이용해 비즈니스 및 데이터의 정합성을 맞춘다.

여기서 보상 트랜젝션이란 어떤 서비스에서 트랜젝션 처리에 실패할 경우 그 서비스의 앞선 다른 서비스에서 처리된 트랜젝션을 되돌리게 하는 트랜잭션이다.

Saga 패턴의 한계점은 **데이터의 일관성이 실시간으로 맞지 않을수 있다**는 것이다. 하지만 결과적 일관성(eventual consistency)를 보장해준다.



### 읽기와 쓰기 분리: CQRS 패턴

CQRS(Command Query Responsibility Segregation) 패턴이란 읽기작업과 CUD(Create,Update,Delete)작업을 구별하는 패턴을 말한다.

두가지 방식으로 구현될수 있다.

1. 하나의 저장소에서 읽기 모델과 쓰기 모델을 분리하여, 명령 API는 쓰기 모델에 데이터를 쓰고 조회 API는 읽기 모델에 데이터를 조회한다.
2. 쓰기 데이터 저장소와 읽기 데이터 저장소를 독립적으로 둔다.

위 방식으로 하면 읽기 작업과 쓰기 작업을 보다 효율적으로 처리할수 있다.

명령 서비스와 읽기 서비스 간에 데이터 정합성을 맞추기 위해서, 관계형 데이터베이스의 변경분을 카프카와 같은 메시지 브로커에 전송하고 읽기 서비스에서는 메시지 브로커의 이벤트를 구독하고 있다가 읽기용 모델(또는 저장소)의 데이터를 최신상태로 동기화 할수 있다.



### API 조합과 CQRS

여러개의 마이크로 서비스와 연계해서 서비스로 제공하는 경우에는 먼저 **API 조합** 방법을 생각해볼수 있다.

이 방법은 상위 서비스에서 하위의 여러 마이크로 서비스를 호출해서 기능을 제공하는 방식이다. 하지만 이 방법은 상위 서비스가 하위 서비스에 의존하게 된다는 문제점이 존재한다.

이를 개선하기 위해 CQRS를 제공할수 있다. 여러 하위 서비스에서 정보가 변경되는 시점에 상위 서비스에 이벤트를 발행하면 상위 서비스에서는 해당 이벤트를 수신하여 자신의 저장소에 데이터를 동기화 할수 있다. 이 경우에는 다른 원천 서비스가 순간적인 장애가 생긴다고 해도 주문 이력 서비스가 영향을 받지 않는다.



### 쓰기 최적화: 이벤트 소싱 패턴

사가 패턴 및 CQRS 패턴에서는 저장소에 데이터를 저장하는 것과 메시지를 보내는 작업이 원자성을 지녀야 한다. 기존에는 원자성을 보장하지 못할 뿐만 아니라 서비스가 스케일 아웃될때 동일 레코드를 업데이트하게 되면서 서비스들간에 교착상태가 발생할수 있다.

이를 개선하기 위해서 이벤트 소싱 패턴을 사용할수 있다. 이벤트 소싱 패턴에서는 트랜젝션 자체를 이벤트 저장소에 저장하고, 다른 서비스에서 해당 트랜젝션 정보를 읽어와서 구체화 한다. 이 방식은 다음과 같은 장점이 있다.

- 저장소에 데이터를 저장하는 것과 다른 서비스로 메시지를 보내는 과정이 원자성 보장
- 이벤트 저장소에 이벤트가 단순히 추가되는 형태의 쓰기 작업이므로 성능 향상
- 정확한 audit(감사)로깅 제공
- 외부 애플리케이션에 이벤트를 전달하는 것도 저장한 이벤트를 전송하면 되기 때문에 간단한 편이다.

자바 진영에서는 Axon Framework와 Eventuate라는 프레임워크가 주로 사용된다.



