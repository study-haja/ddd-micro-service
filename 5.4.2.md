## 이벤트 스토밍 워크숍 진행



### 1. 도메인 이벤트 찾기

* 시간의 흐름에 따라 시스템의 동작을 의미하는 도메인 이벤트를 도출한다.
* 이벤트 왼쪽에서 오른쪽으로 시간 흐름순으로 붙이되 이벤트가 연쇄적으로 발생하는 경우 바로 옆에 붙인다.
* 또한 같은 시점에 비즈니스 조건에 따라 대체적으로 발생할 수 있는 이벤트는 세로로 아래쪽에 같은 선상에 붙인다.
* 시스템 화면을 연상하지 말고 비즈니스 흘러감에 따라 비즈니스를 구성하는 요소들의 상태가 어떻게 변경되는지를 생각한다.
* 예를 들면 이벤트 [회원 가입됌], [회원 수정됌], [회원 삭제됌], [상품 등록됌], [상품 결제 됌] 등이 도출 될 수 있다.



### 2. 외부 시스템 도출

* 이벤트를 도출하면서 레거시 시스템이나 외부 시스템과의 연계를 통해 업무의 흐름이 진행될 때 표시하는 과정이다.
* 연계가 필요한 시스템을 모두 도출하고 명사 형태로 적는다.
* 예를 들면 [유효성 판단 시스템], [결제 시스템], [이메일 시스템] 등이 있다.



### 3. 커맨드 도출

* 도메인 이벤트를 찾은 후에 이 이벤트를 동작하게 하는 커맨드를 찾는다.
* 커맨드명은 도메인 이벤트를 동작하게 하는 것으로 명령형, 즉 동사 형태로 작성한다.
* 하나의 커맨드에 의해 여러 개의 이벤트가 동시 또는 연속해서 발생할 수 있으며, 조건에 따라 하나의 커맨드에 여러 개의 다른 이벤트가 발생할 수 있음에 유의한다.
* 예를 들면 [회원가입], [회원정보 수정], [회원 정보 삭제], [상품 등록] 등이 있다.



### 4. 핫스폿 도출

* 워크숍을 진행하면서 의문이나 결정하기 힘든 상황이나 정의하기 어려운 것들을 작성한다.
* 예를들면 [상품 취소 가능 시점 확인] 등이 있다.



### 5. 액터 도출

* 커맨드까지 찾고 나면 커맨드를 실행하는 액터를 도출하는데, 액터는 사용자, 조직, 역할자를 의미한다.
* 액터는 추상적으로 식별하지 않고 비즈니스를 수행하는 구체적인 역할을 고려해서 도출한다.
* 회원이나 관리자가 아닌 비즈니스를 실제로 수행하는 역할자들을 도출해내려고 해야 한다.
* 예를 들면 [판매자], [구매자], [배송자], [시스템관리자], [게스트], [회원] 등이 있다.
* 그리고 액터를 도출했으면 식별한 커맨트와 이벤트를 검토한다.
* 문장이 자연스럽지 않다면 커맨드와 도메인 이벤트를 변경하거나 새로 도출해야 한다.
* 예를 들면 [판매자가 상품을 등록하면 상품등록됨이라는 이벤트가 발생함으로써 시스템이 동작한다.] 등이 될 수 있다.



### 6. 애그리거트 정의

* 애그리거트는 커맨드와 도메인 이벤트가 영향을 주는 데이터 요소로, 도메인의 실체 개념을 표현하는 개체인 엔티티가 된다.
* 액터와 마찬가지로 애그리거트도 구체적인 표현으로 도출하는 것이 좋은데, 그 이유는 애거리거트를 구체적으로 식별할수록 컨텍스트의 경계를 식별하는 데 유용하기 때문이다.
* 예를 들면 [회원], [상품], [결제], [배송] 등이 있다.



### 7-1. 바운디드 컨텍스트 그리기

* 이름이 같거나 유사한 애그리거트와 완전히 다른 애그리거트를 구분해서 경계를 그린다.
* 즉 애그리거트를 그룹화하여 바운디드 컨텍스트를 만든다.
* 컨텍스트 이름은 바운디드 컨텍스트 내의 애그리거트 이름으로 정의한다. (전부 아우를수 있는 대표 이름)
* 멀리 떨어져 있는 애그리거트 경우 모두 옮긴다.
* 즉 응집성 있도록 동일한 애그리거트 중심으로 모듈화를 해야한다.
* 그리고 애그리거트가 달라지는 시점을 잘 고민해야 한다.
* 예를 들면 [상품], [카테고리] 2개 의 컨텍스트를 둘 수 있지만, 1개로 묶어 정의할 수 있다.



### 7-2 정책을 도출하면서 연관관계 생각하기

* 정책은 이벤트 뒤에 따라오는 반응적인 비즈니스 로직으로, 어딘가에 존재하는 커맨드를 동작하게 한다.
* 정책은 다음과 같이 정의한다.
  * [도메인 이벤트] 할 때는 항상 [커맨드] 한다.
* 따라서 정책은 도메인 이벤트와 커맨드 사이에 존재한다.
* 정책은 같은 바운디드 컨택스트에 존재할 수도 있고 아닐 수도 있다.
* 정책 도출은 흐름의 방향대로 화살표로 표현한다.
* 예를 들면 [구매 컨택스트에서 구매가 완려되면 배송 요청됨이라는 이벤트가 발생하고, 이 이벤트와 연관 된 배송 생성] 이라는 정책 예시를 들 수 있다.



### 8.  컨텍스트 매핑

* 컨텍스트 관계를 작성할 때는 호출 관계의 방향을 고려해야 한다.
* 또한 호출할 때 호출 방식, 즉 동기 방식으로 호출이 필요한지, 비동기 방식의 호출이 필요한지 판단해서 작성해야 한다.
* 호출방식은 데이터의 일관성 측면과 컨텍스트의 가용성 측면을 고려해서 선택한다.
* 컨텍스트 간에 항상 일관된 데이터가 필요한 관계는 동기 호출로 표현하고 결과적 일관성으로 충분히 처리 가능한 관계는 비동기 방식의 호출로 표현한다.
* 일반적으로 동기방식은 두 컨텍스트 간의 의존도가 높아진다.
* 반면 비동기 방식은 다른 컨텍스트가 이벤트를 받아 처리할 수 있게 하는 방식이기 때문에 의존도가 낮아진다.
* 따라서 반드시 실시간 정합성이 필요한 경우가 아니라면 비동기 방식의 연계를 고려하는 것이 좋다.
* 예를 들면 다음과 같다.
  * 고객이 상품을 주문할 때 상품 구매를 위해 클라이언트를 통해 구매 컨텍스트에 **동기 방식**으로 접근한다.
  * 그러면 상품의 현재 가격을 가져오기 위해 상품 컨텍스트에 **동기 방식** 으로 연동하고, 회원 컨텍스트에도 현재의 결제 정보와 배송지 정보를 가져오기 위해 **동기 방식** 으로 연동한다.
  * 그러나 구매 컨텍스트와 배송 컨텍스트는 연관관계를 **비동기**로 정의됐는데, 이러한 경우 배송 컨텍스트에 장애가 발생한 경우에도 주문을 계속 처리할 수 있는 고가용성을 보장한다.
* 최근에는 메시지 브로커의 성능과 안정성이 높아져 동기 방식은 꼭 필요한 경우에만 사용하고 많은 부분을 비동기로 데이터 정합성을 맞춘다.



### 8-2 마이크로서비스 상세 설계를 위한 입력물

* 이벤트 스토밍 결과물에 따라 마이크로 서비스의 프론트와 백앤드 모델링에 활용된다.
* 그렇기 때문에 프로젝트가 끝날때까지 결과물을 붙여놓으며 계속해서 생각하고 구체화 시켜 프로젝트를 진행하는 것이 좋다.