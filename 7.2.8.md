## 외부 영역 - REST 컨트롤러 개발

* UserResource에서 @PreAuthorize라는 어노테이션을 통해 사용자 권한이 ADMIN일 경우에만 요청 가능하도록 허용
* 생각해볼점
  * UserResource에서 Service(유스케이스), Repository(레포지토리) 를 같이 사용했는데 같은 선상에 있는건지?
    * 이렇게 사용하면 어떤게 좋은건지
    * MVC?



## MSA 패턴 종류



### Two Phase Commit

* 2단계에 거쳐서 데이터를 영속화 하는 작업
* DB가 분산되었을 때, 트랜잭션을 조율하는 조정자(Cooredinator)가 존재
* 조정자는 트랜잭션 요청이 들어왔을 때 두 단계를 거쳐 트랜잭션 진행을 담당
* Prepare -> Commit
* 만약 두단계를 거치는 과정에서 연관된 DB중 하나의 DB라도 Commit을 할 수 없는 상황이라면, 모든 DB 롤백을 요구
* 트랜잭션을 종료하면 모든 DB 데이터가 영속화
* 따라서 트랜잭션의 범위는 데이터 처리는 DB 전체이다.
* MSA에서 문제점
  * DBMS에서 분산 트랜잭션을 지원해야 적용이 가능 -> NoSQL 같은 제품은 지원 x -> 즉 폴리글랏 구성이 어려움
  * MSA는 각기 다른 APP에서 API간으로 통신을 통해 서비스 요청이 이루어지기 때문에 구현이 쉽지 않음



### Saga Pattern

* 트랜잭션 관리주체가 DBMS가 아닌 Application에 있음
* 즉 로컬 트랜잭션만 처리
* 로컬들끼리 트랜잭션을 연결하고 싶으면 이벤트를 발생시켜야함
  * 이러한 구조로 인해 이벤트마다 성공, 실패 (커밋, 롤백)을 구현해야함
* Saga 패턴은 데이터 격리성을 보장해주지 않음
  * 하지만 트랜잭션 고나리를 통해 최종 일관성을 달성할 수 있기 때문에 분산되어 있는 DB간에 정합성을 맞출 수 있음
  * 또한 Application에서 트랜잭션 관리를 하기 때문에 다른 DBMS 제품군을 사용가능
* Saga 패턴의 종류
  * Choreography-Based Saga
    * 자신이 보유한 서비스 내 local 트랜잭션을 관리하며, 트랜잭션이 종료되면 완료 이벤트를 발행
    * 그 다음으로 수행해야할 트랜잭션이 있다면, 해당 트랜잭션을 수행해야하는 App에서 완료 이벤트를 수신받고 다음 작업을 처리
    * 이때 전달하는 방식은 메시지 큐를 이용해서 비동기 방식으로 전달할 수 있음
    * APP별로 트랜잭션을 관리하는 로직이 있음 -> 중간에 실패하면 해당 트랜잭션 취소 처리를 실패한 APP에서 롤백 이벤트를 발생시켜 처리
    * 구축은 쉬우나 운영자 입장에서는 트랜잭션의 현재 상태를 알기 어려움
  * Orchestration-Based Saga
    * 트랜잭션 처리를 위해 Saga 인스턴스 매니저가 별도로 존재
    * APP내에 모든 트랜잭션은 인스턴스 매니저가 처리
    * 중간에 실패시 롤백 트랜잭션을 발동시켜 일관성을 유지
    * 모든 관리를 매니저가 호출하기 때문에 분산 트랜잭션의 중앙 집중화가 이루어짐 (Orchestration)
      * 이는 서비스간의 복잡성이 줄어들고 구현 테스트가 상대적으로 쉬움
      * 또한 트랜잭션의 현재 상태를 매니저가 알고 있기 때문에 롤백을 쉽게 할 수 있음
      * 하지만 이를 관리하기 위한 Orchestrator 서비스가 추가되어야 하기 때문에 인프라 구현의 복잡성이 증가됌



### Event Sourcing

* 모든 상태 변화를 순서대로 이벤트로 보관하여 처리하는 개념
* 모든 상태를 이벤트의 흐름으로 처리하므로써 Application 개발을 간소화하고 분산환경에 적절히 대응 가능
* 모든 이벤트들은 시간 순으로 기록되며 각 서비스들은 자신이 필요한 이벤트만 보고 있다가 최신의 상태를 유지하면 됌
* 이벤트 소싱이 완벽하게 동작하려면 모든 이벤트가 기록되어야함
* 그리고 이벤트를 받지 못하는 서비스가 없도록 재전송이 가능해야 함
* 또한 브로드캐스팅이 되어야 분산된 환경에서도 완벽히 동작 가능
* 이벤트 기반으로 구현하면 보다 손쉽게 구현이 가능하며, 각 서비스 간의 loosed coupling이 가능 (느슨한 결합)
* 카프카 스트림즈를 통해 이벤트 소싱 가능



### CQRS

* Command와 Query의 책임을 분리하자는 의미
* Command : CUD
* Query : R
* 이벤트 소싱과 연관되서 말하자면 Event는 Command (상태 변경되는 경우) 만 기록하면 됌
* 단순 Query인 경우 모델의 정보를 변화시키지 않기 때문에 그 기능을 분리하여 좀 더 손쉽게 Event Sourcing Pattern을 적용



### Backend For Front

* 최신 비지니스 어플리케이션은 프론트와 백엔드를 분리해서 구현
* 그리고 API, GraphQL을 통해 연결
* 동작하는 여러개의 프론트들이 모두 스팩이 다 다르기 때문에 분리해서 구현
* 특징
  * 특정 UI에 맞게 최적화 가능, 더 높은 보안
  * BFF는 비지니스 로직을 포함해서는 안됌 -> 클라이언트 별 로직 및 동작만 포함해야함
  * API 요구사항이 다른 여러 UI가 있는 경우 적합
* API Gateway
  * API 서버 앞단에서 모든 API 서버들의 엔드포인트를 단일화 해주는 또다른 서버
  * 인증과 인가 기능을 가지고 있음
  * 메시지의 내용에 따라 어플리케이션 내부에 잇는 마이크로서비스로 라우팅하는 역할을 담당
  * 주요 기능
    * 인증 및 인가
    * 요청 절차 단순화
      * 여러 클라이언트의 요청을 단일 클라이언트의 요청으로 대체 가능
    * 라우팅 및 로드밸런싱
    * 서비스 오케스트레이션
      * 오케스트레이션은 여러 개의 마이크로 서비스를 묶어 새로운 서비스를 만드는 개념
      * 과도하게 로직을 넣는 것은 x
    * 서비스 디스커버리
      * 서비스를 호출하기 위해서는, 서비스 마다 IP와 포트를 알아야 함
      * 클라우드 환경에서는 동적으로 정보가 바뀌기 때문에 API Gateway에서는 서버사이드나, 클라이언트 사이드 기준으로 하여 서비스 디스커버리를 구현 가능
  * 고려 사항
    * 내부 MSA와 결합하기 때문에 SOA, ESB에서 발생했던 문제점이 다시 발생 가능
    * Scale-out 적용이 유연하게 일어나지 않을 경우, API Gateway가 병목지점이 되어 애플리케이션의 성능저하가 일어날 수 있음
    * API Gateway라는 추가적인 계층이 만들어지는 것이기 때문에, 네트워크 latency가 증가

